<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Módulos :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 10;var sandboxLoadFiles = ["code/packages_chapter_10.js","code/chapter/07_robot.js"];
  </script>
</head>

<article>
<nav><a href="09_regexp.html" title="previous chapter">◀</a> 
  <a href="index.html" title="cover">◆</a> <a href="11_async.html" title="next chapter">▶</a>
</nav>

<h1><span class=chap_num>Chapter 10</span>Módulos</h1>

<blockquote>

<p><a class="p_ident" id="p_89tkP6lWaz" href="#p_89tkP6lWaz" tabindex="-1" role="presentation"></a>Escreva código que seja fácil de deletar, difícil de estender.</p>

<footer>Tef, <cite>Programming is Terrible</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_10.jpg" alt="Picture of a building built from modular pieces"></figure>

<p><a class="p_ident" id="p_aO++J4OJSX" href="#p_aO++J4OJSX" tabindex="-1" role="presentation"></a>O programa ideal tem uma estrutura limpa como cristal. É fácil de explicar como funciona e cada parte tem um papel bem definido.</p>

<p><a class="p_ident" id="p_yUBXc3r+t+" href="#p_yUBXc3r+t+" tabindex="-1" role="presentation"></a>Um programa real típico cresce organicamente. Novas funcionalidades são adicionadas conforme novas necessidades surgem. Estruturação e preservação da estrutura é um trabalho adicional, trabalho que será pago somente no futuro, da próxima vez que alguém trabalhar no programa. Então é tentador negligenciar isso e permite as partes do programa ficarem profundamente confusas.</p>

<p><a class="p_ident" id="p_3mhuibfk4V" href="#p_3mhuibfk4V" tabindex="-1" role="presentation"></a>Isso causa dois problemas práticos. Primeiro, entender este sistema é difícil. Se tudo puder tocar todo o resto, é difícil olhar uma determinada parte isolada. Você é forçado a construir uma compreensão holística de toda coisa. Segundo, se você quer usar qualquer funcionalidade do programa em outra situação, re-escrever será mais fácil do que tentar desenrolar a função de seu contexto.</p>

<p><a class="p_ident" id="p_fhkvcTfWq3" href="#p_fhkvcTfWq3" tabindex="-1" role="presentation"></a>O termo “grande bola de lama” é geralmente usado para programas grandes e sem estrutura. Tudo fica junto e quando você tenta pegar uma parte, toda a coisa despenca e você fica com as mãos sujas.</p>

<h2><a class="h_ident" id="h_45kWH4U4Bd" href="#h_45kWH4U4Bd" tabindex="-1" role="presentation"></a>Módulos</h2>

<p><a class="p_ident" id="p_2LkUjN4nYr" href="#p_2LkUjN4nYr" tabindex="-1" role="presentation"></a><em>Módulos</em> são uma tentativa de evitar estes problemas. Um módulo é uma parte de programa que especifica quais partes ele depende (são as <em>dependências</em>) em que as funcionalidades ele fornece para outros módulos (são as <em>interfaces</em>).</p>

<p><a class="p_ident" id="p_nZOELUjUAP" href="#p_nZOELUjUAP" tabindex="-1" role="presentation"></a>Interfaces de módulo têm muito em comum com interfaces de objeto como vimos no <a href="06_object.html#interface">Capítulo 6</a>. Eles fazem parte do módulo disponível no mundo externo e mantém o resto privado. Restringindo o modo como os módulos interagem entre si, o sistema fica mais parecido com Lego, onde as peças interagem através de conectores bem definidos e menos como lama, onde tudo se mistura.</p>

<p><a class="p_ident" id="p_yg+3xI1U2r" href="#p_yg+3xI1U2r" tabindex="-1" role="presentation"></a>A relação entre módulos é chamada dependência. Quando um módulo precisa de outro módulo, é dito que ele depende daquele módulo. Quando este fato é claramente especificado no próprio módulo, pode ser utilizado para descobrir quais módulos devem estar presentes para que o módulo desejado seja utilizado e carregar automaticamente suas dependências.</p>

<p><a class="p_ident" id="p_kEJDx7LX7z" href="#p_kEJDx7LX7z" tabindex="-1" role="presentation"></a>Para separar módulos desta forma, cada um precisa de sua privacidade escopo.</p>

<p><a class="p_ident" id="p_cMpOrR1LgV" href="#p_cMpOrR1LgV" tabindex="-1" role="presentation"></a>Apenas colocando seus arquivos JavaScript em diferentes arquivos não satisfaz esses requerimentos. Os arquivos ainda compartilham o mesmo <em>namespace</em> global. Eles podem, intencionalmente ou acidentalmente, interferir uns com os outros e a estrutura de dependência permanece escondida. Podemos fazer melhor, como veremos mais tarde neste capítulo.</p>

<p><a class="p_ident" id="p_Exu1PRcDFO" href="#p_Exu1PRcDFO" tabindex="-1" role="presentation"></a>Definir uma estrutura de módulo para um programa pode ser difícil. Na fase onde você está ainda explorando o problema, testar soluções diferentes para ver qual irá funcionar, você pode querer não se preocupar tanto com isso, pois pode ser uma grande distração. Quando você tiver algo que parece definitivo, é um bom momento dar um passo atrás e organizar o programa.</p>

<h2><a class="h_ident" id="h_4h/PDx9kdI" href="#h_4h/PDx9kdI" tabindex="-1" role="presentation"></a>Pacotes</h2>

<p><a class="p_ident" id="p_HRJYWAjcwT" href="#p_HRJYWAjcwT" tabindex="-1" role="presentation"></a>Uma das vantagens de construir um programa separando por partes e sendo possível executar essas partes separadamente é que você é capaz de executar as mesmas partes em diferentes programas.</p>

<p><a class="p_ident" id="p_QUbyZebIpX" href="#p_QUbyZebIpX" tabindex="-1" role="presentation"></a>Mas como você faz isso? Digamos que eu queira usar a função <code>parseINI</code> do <a href="09_regexp.html#ini">Capítulo 9</a> em outro programa. Se está claro no que esta função depende (neste caso, nada), podemos simplesmente copiar todo código necessário no novo projeto. Mas então se eu encontrar um erro no código, provavelmente irei corrigir no programa em que estarei trabalhando e esqueço de corrigir no código de onde copiei.</p>

<p><a class="p_ident" id="p_4P8cmHvEXh" href="#p_4P8cmHvEXh" tabindex="-1" role="presentation"></a>Quando você começa a duplicar código, se verá rapidamente perdendo tempo e energia movendo cópias e as mantendo atualizadas.</p>

<p><a class="p_ident" id="p_QMrhUgP+Hw" href="#p_QMrhUgP+Hw" tabindex="-1" role="presentation"></a>Aí que entram os <em>pacotes</em>. Um pacote é um pedaço de um código que pode ser distribuído (copiado e instalado). Pode conter um ou mais módulos e possui informação sobre outros pacotes que ele depende. Um pacote também costuma vir com documentação explicando o que ele faz, assim pessoas que não o escreveram também poderão utilizá-lo.</p>

<p><a class="p_ident" id="p_sEDidMyD6u" href="#p_sEDidMyD6u" tabindex="-1" role="presentation"></a>Quando um problema é encontrado no pacote ou uma nova funcionalidade é adicionada, o pacote é atualizado. Agora o programa que depende dele (que também podem ser pacotes) podem ser atualizados versão.</p>

<p id="modules_npm"><a class="p_ident" id="p_IWKOto4Hc8" href="#p_IWKOto4Hc8" tabindex="-1" role="presentation"></a>Trabalhar desta forma requer infra-estrutura. Precisamos de um lugar para armazenar e encontrar os pacotes e uma forma conveniente de instalar e atualizá-los. No mundo JavaScript, essa infra-estrutura é fornecida pelo NPM (<a href="https://npmjs.org"><em>npmjs.org</em></a>).</p>

<p><a class="p_ident" id="p_/ixfkl4uwS" href="#p_/ixfkl4uwS" tabindex="-1" role="presentation"></a>NPM é duas coisas: um serviço online onde podemos fazer download (e upload) dos pacotes e programas (juntos com Node.js) que ajudam a instalá-los e gerenciá-los.</p>

<p><a class="p_ident" id="p_G/57FuG4Fe" href="#p_G/57FuG4Fe" tabindex="-1" role="presentation"></a>No momento em que este texto foi escrito, há próximo de 1 milhão de diferentes pacotes disponíveis no NPM. Uma grande parte é lixo, devo dizer, mas quase todos os pacotes úteis estão disponíveis lá. Por exemplo, a função INI file parser, similar ao que foi construído no <a href="09_regexp.html">Capítulo 9</a> está disponível como pacote <code>ini</code>.</p>

<p><a class="p_ident" id="p_CjqX3t8gcS" href="#p_CjqX3t8gcS" tabindex="-1" role="presentation"></a><a href="20_node.html">Capítulo 20</a> irá mostrar como instalar estes pacotes usando linha de comando <code>npm</code>.</p>

<p><a class="p_ident" id="p_0DcCqZ6H0P" href="#p_0DcCqZ6H0P" tabindex="-1" role="presentation"></a>Ter pacotes de alta qualidade disponíveis é extremamente valioso. Isso quer dizer que normalmente podemos evitar de ter que inventar um programa que diversas pessoas já escreveram antes e ter uma sólida e bem testada implementação apenas apertando alguns botões.</p>

<p><a class="p_ident" id="p_BXYq4Xalzv" href="#p_BXYq4Xalzv" tabindex="-1" role="presentation"></a>É barato copiar software, então quando alguém já escreveu, distribuir para outras pessoas é um processo eficiente. Escrevê-lo da primeira vez que <em>é</em> o trabalho e responder a pessoas que encontraram problemas no código ou querem propor novas funcionalidades, é ainda mais trabalho.</p>

<p><a class="p_ident" id="p_B1c87ed4m0" href="#p_B1c87ed4m0" tabindex="-1" role="presentation"></a>Por padrão, você possui o copyright do seu código e outras pessoas podem apenas usá-lo com sua permissão. Mas como algumas pessoas são legais e porque publicar bons softwares podem te deixar um pouco mais famoso entre programadores, muitos pacotes são publicados sobre a licença que explicitamente permitem outras pessoas a utilizá-los.</p>

<p><a class="p_ident" id="p_w/ZAooQrog" href="#p_w/ZAooQrog" tabindex="-1" role="presentation"></a>A maioria dos códigos do NPM possui este tipo de licença. Algumas licenças requerem que você publique o código que você criou utilizando o pacote baixado sobre a mesma licença. Outros são menos exigentes, apenas requerindo que você mantenha a licença com o código conforme você o distribui. A maioria da comunidade JavaScript usa o último tipo de licença. Quando utilizar o pacote de outras pessoas, tenha certeza de conhecer sua licença.</p>

<h2><a class="h_ident" id="h_QQ/m+TRmqd" href="#h_QQ/m+TRmqd" tabindex="-1" role="presentation"></a>Improvised modules</h2>

<p><a class="p_ident" id="p_xoPll9P5zv" href="#p_xoPll9P5zv" tabindex="-1" role="presentation"></a>Até 2015, a linguagem JavaScript não possuía nenhum sistema de módulos embutido. No entanto, as pessoas têm construído grandes sistemas em JavaScript ao longo de uma década, embora precisassem dos módulos.</p>

<p><a class="p_ident" id="p_87LteBlL83" href="#p_87LteBlL83" tabindex="-1" role="presentation"></a>Então desenvolveram seus próprios sistema de módulos para a linguagem. Você pode usar as funções JavaScript para criar escopos locais e objetos para representar sa interfaces de módulos.</p>

<p><a class="p_ident" id="p_E4na7SHdcb" href="#p_E4na7SHdcb" tabindex="-1" role="presentation"></a>Este é um módulo que irá entre os nomes e números dos dias (retornando como <code>Date</code> pelo método <code>getDate</code> ). Sua interface consiste do <code>weekDay.name</code> e <code>weekDay.Number</code> e esconde sua ligação local <code>name</code> dentro do escopo da função que é imediatamente chamada.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_m+yRMF5NXw" href="#c_m+yRMF5NXw" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">weekDay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">const</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">&quot;Sunday&quot;</span>, <span class="cm-string">&quot;Monday&quot;</span>, <span class="cm-string">&quot;Tuesday&quot;</span>, <span class="cm-string">&quot;Wednesday&quot;</span>,
                 <span class="cm-string">&quot;Thursday&quot;</span>, <span class="cm-string">&quot;Friday&quot;</span>, <span class="cm-string">&quot;Saturday&quot;</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">&quot;Sunday&quot;</span>)));
<span class="cm-comment">// → Sunday</span></pre>

<p><a class="p_ident" id="p_jI8CYNcqhP" href="#p_jI8CYNcqhP" tabindex="-1" role="presentation"></a>Este estilo de módulos fornece isolamento, até um certo poto, mas não declara dependências. Ao invés disso, apenas coloca sua interface no escopo global e espera suas dependências, se houver, que façam o mesmo. Por muito tempo esta foi a principal abordagem utilizada na programação web, mas a maior parte é obsoleta agora.</p>

<p><a class="p_ident" id="p_Nonur4WYaS" href="#p_Nonur4WYaS" tabindex="-1" role="presentation"></a>Se quiseremos fazer as relações de dependência parte do código, teremos que tomar controle das dependências de carregamento. Fazer isso requer ser capaz de executar strings no código. JavaScript pode fazer isso.</p>

<h2 id="eval"><a class="h_ident" id="h_oeOkEDaadU" href="#h_oeOkEDaadU" tabindex="-1" role="presentation"></a>Evaluating data as code</h2>

<p><a class="p_ident" id="p_+i68gFs2nw" href="#p_+i68gFs2nw" tabindex="-1" role="presentation"></a>Há várias formas de obter dados (uma string de código) e executar como parte do programa atual.</p>

<p><a class="p_ident" id="p_LXmI7kLovT" href="#p_LXmI7kLovT" tabindex="-1" role="presentation"></a>A forma mais óbvia é com o operator especial <code>eval</code>, que irá executar uma string no <em>atual</em>escopo. Geralmente é uma má idéia porque quebra algumas propriedades que o escopo possui normalmente, tal como sendo facilmente previsível qual ligação a qual um dado nome se refere.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_14x3bOXX9G" href="#c_14x3bOXX9G" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-keyword">function</span> <span class="cm-def">evalAndReturnX</span>(<span class="cm-def">code</span>) {
  <span class="cm-variable">eval</span>(<span class="cm-variable-2">code</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">x</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evalAndReturnX</span>(<span class="cm-string">&quot;var x = 2&quot;</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span>);
<span class="cm-comment">// → 1</span></pre>

<p><a class="p_ident" id="p_XSk++fDD1X" href="#p_XSk++fDD1X" tabindex="-1" role="presentation"></a>Uma forma menos pavorosa de interpretar dados como código é utilizar <code>Function</code> construtora. Ela leva dois argumentos: uma string contendo uma lista de nome de argumentos separada por vírgula e uma string contendo o corpo da função. It wraps the code in a function value so that it gets its own scope and won’t do odd things with other scopes.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Mc9BAi4AVK" href="#c_Mc9BAi4AVK" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">plusOne</span> <span class="cm-operator">=</span> <span class="cm-variable">Function</span>(<span class="cm-string">&quot;n&quot;</span>, <span class="cm-string">&quot;return n + 1;&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">plusOne</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 5</span></pre>

<p><a class="p_ident" id="p_qLOG+xHf7C" href="#p_qLOG+xHf7C" tabindex="-1" role="presentation"></a>Isso é precisamente o que precisamos para um sistema de módulos. Podemos envolver o código do módulo em uma função e usar o escopo dessa função como o escopo do módulo.</p>

<h2><a class="h_ident" id="h_N33QHgUxbG" href="#h_N33QHgUxbG" tabindex="-1" role="presentation"></a>CommonJS</h2>

<p id="commonjs"><a class="p_ident" id="p_ceEirT3szX" href="#p_ceEirT3szX" tabindex="-1" role="presentation"></a>A abordagem mais utilizada de utilizar os módulos JavaScript é chamado <em>CommonJS modules</em>. Node.js utiliza e é o sistema mais utilizado pelos pacotes NPM.</p>

<p><a class="p_ident" id="p_K85DVOLN8t" href="#p_K85DVOLN8t" tabindex="-1" role="presentation"></a>O coneceito principal nós módulos JS comuns é uma função chamada <code>require</code>. Quando esta função é chamada com o nome do módulo de uma dependência, ele garante que o módulo é carrgeado e retorna sua interface.</p>

<p><a class="p_ident" id="p_N0NSrC+Ir0" href="#p_N0NSrC+Ir0" tabindex="-1" role="presentation"></a>Como o carregamento envolve o código do módulo em uma função, módulos automaticamente pegam seu próprio escopo local. A única coisa que eles têm que fazer é chamar <code>require</code> para acessar suas dependências e colocar sua interface no objeto ligado ao <code>exports</code>.</p>

<p><a class="p_ident" id="p_x0hNHKNneY" href="#p_x0hNHKNneY" tabindex="-1" role="presentation"></a>Este exemplo de módulo fornece uma função de formatação de data. Ele utiliza dois pacotess do NPM-<code>ordinal</code> para converter os números em strings como <code>&quot;1st</code> e <code>&quot;2nd</code> e <code>date-names</code> para pegar os nomes em inglês dos dias da semana e meses. Ele exporta uma única função <code>formatDate</code>, que recebe um objeto <code>Date</code> e uma string template.</p>

<p><a class="p_ident" id="p_nYw9B9WrTH" href="#p_nYw9B9WrTH" tabindex="-1" role="presentation"></a>O template da String pode conter códigos que direcionam o formato, como <code>YYYY</code> para o ano completo e <code>Do</code> para o número ordinal do dia do mês. Você pode passar uma string como <code>&quot;MMMM Do YYYY&quot;</code>para receber um retorno como “Novembro 22nd 2017”.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_hEFnba6fud" href="#c_hEFnba6fud" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">ordinal</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;ordinal&quot;</span>);
<span class="cm-keyword">const</span> {<span class="cm-def">days</span>, <span class="cm-def">months</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;date-names&quot;</span>);

<span class="cm-variable">exports</span>.<span class="cm-property">formatDate</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">date</span>, <span class="cm-def">format</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">format</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/YYYY|M(MMM)?|Do?|dddd/g</span>, <span class="cm-def">tag</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;YYYY&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">date</span>.<span class="cm-property">getFullYear</span>();
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;M&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">date</span>.<span class="cm-property">getMonth</span>();
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;MMMM&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable">months</span>[<span class="cm-variable-2">date</span>.<span class="cm-property">getMonth</span>()];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;D&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">date</span>.<span class="cm-property">getDate</span>();
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;Do&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable">ordinal</span>(<span class="cm-variable-2">date</span>.<span class="cm-property">getDate</span>());
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">tag</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;dddd&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable">days</span>[<span class="cm-variable-2">date</span>.<span class="cm-property">getDay</span>()];
  });
};</pre>

<p><a class="p_ident" id="p_UpP/vvtbfb" href="#p_UpP/vvtbfb" tabindex="-1" role="presentation"></a>A interface do <code>ordinal</code> é uma única função, enquanto <code>date-names</code> exporta um objeto contendo múltiplas coisas - os dois valores que usamos são um array de nomes. Desestruturar é muito conveninente quando estamos criando ligações para interfaces importadas.</p>

<p><a class="p_ident" id="p_KewnHpKUZn" href="#p_KewnHpKUZn" tabindex="-1" role="presentation"></a>O módulo adiciona sua função de interface to <code>exports</code>, então o módulo que depende disso ganhará acesso. Podemos utilizar o módulo deste forma:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_pWURcHuHTt" href="#c_pWURcHuHTt" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">formatDate</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;./format-date&quot;</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">formatDate</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2017</span>, <span class="cm-number">9</span>, <span class="cm-number">13</span>),
                       <span class="cm-string">&quot;dddd the Do&quot;</span>));
<span class="cm-comment">// → Friday the 13th</span></pre>

<p id="require"><a class="p_ident" id="p_cSQjWjJ/0p" href="#p_cSQjWjJ/0p" tabindex="-1" role="presentation"></a>Podemos definir <code>require</code> na sua forma mínima, conforme abaixo:</p>

<pre class="snippet cm-s-default" data-language="javascript"  data-sandbox="require"><a class="c_ident" id="c_CSMfqoYOzp" href="#c_CSMfqoYOzp" tabindex="-1" role="presentation"></a><span class="cm-variable">require</span>.<span class="cm-property">cache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-keyword">function</span> <span class="cm-def">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>)) {
    <span class="cm-keyword">let</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: {}};
    <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">module</span>;
    <span class="cm-keyword">let</span> <span class="cm-def">wrapper</span> <span class="cm-operator">=</span> <span class="cm-variable">Function</span>(<span class="cm-string">&quot;require, exports, module&quot;</span>, <span class="cm-variable-2">code</span>);
    <span class="cm-variable-2">wrapper</span>(<span class="cm-variable">require</span>, <span class="cm-variable-2">module</span>.<span class="cm-property">exports</span>, <span class="cm-variable-2">module</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>].<span class="cm-property">exports</span>;
}</pre>

<p><a class="p_ident" id="p_sc1VEkBDCY" href="#p_sc1VEkBDCY" tabindex="-1" role="presentation"></a>In this code, <code>readFile</code> is a made-up function that reads a file and returns its contents as a string. Standard JavaScript provides no such functionality—but different JavaScript environments, such as the browser and Node.js, provide their own ways of accessing fileos. The example just pretends that <code>readFile</code> exists.</p>

<p><a class="p_ident" id="p_ZQ7Y55Ii2l" href="#p_ZQ7Y55Ii2l" tabindex="-1" role="presentation"></a>Para evitar carregar o mesmo módulo várias vezes, <code>require</code> mantém um armazenamento (cache) de módulos já carregados. Quando chamado, verifica primeiro se o módulo requerido já foi carregado e se não, o carrega. Isso envolve ler o código do módulo, envolvê-lo em uma função e chamá-lo.</p>

<p><a class="p_ident" id="p_/GC3lL7tMJ" href="#p_/GC3lL7tMJ" tabindex="-1" role="presentation"></a>A interface do pacote <code>ordinal</code> que vimos anteriormente não é um objeto, mas sim uma função. Uma peculiaridade dos módulos CommonJS é que embora o sistema modular crie um objeto de interface vazio para você (vinculado ao <code>exports</code>), podemos substituir com qualquer valor sobrescrevendo <code>module.exports</code>. Isso é feito por muitos módulos para exportar um único valor ao invés da interface objeto.</p>

<p><a class="p_ident" id="p_6/VlHgFpsB" href="#p_6/VlHgFpsB" tabindex="-1" role="presentation"></a>Definindo <code>require</code>, <code>exports</code> e <code>module</code> como parameters para a função wrapper gerada (e passando os valores apropriados quando invocada), o carregamento garante que essas conexões estão disponíveis no módulo scope.</p>

<p><a class="p_ident" id="p_xriS0EN27o" href="#p_xriS0EN27o" tabindex="-1" role="presentation"></a>The way the string given to <code>require</code> is translated to an actual filename or web address differs in different systems. When it starts with <code>&quot;./&quot;</code> or <code>&quot;../&quot;</code>, it is generally interpreted as relative to the current module’s filename. So <code>&quot;./<wbr>format-date&quot;</code> would be the file named <code>format-date.js</code> in the same directory.</p>

<p><a class="p_ident" id="p_L5+LG67XHa" href="#p_L5+LG67XHa" tabindex="-1" role="presentation"></a>When the name isn’t relative, Node.js will look for an installed package by that name. In the example code in this chapter, we’ll interpret such names as referring to NPM packages. We’ll go into more detail on how to install and use NPM modules in <a href="20_node.html">Chapter 20</a>.</p>

<p id="modules_ini"><a class="p_ident" id="p_B5bzWP/zEC" href="#p_B5bzWP/zEC" tabindex="-1" role="presentation"></a>Now, instead of writing our own INI file parser, we can use one from NPM.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_LfcCXOMZGr" href="#c_LfcCXOMZGr" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">parse</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;ini&quot;</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">&quot;x = 10\ny = 20&quot;</span>));
<span class="cm-comment">// → {x: &quot;10&quot;, y: &quot;20&quot;}</span></pre>

<h2><a class="h_ident" id="h_hF2FmOVxw7" href="#h_hF2FmOVxw7" tabindex="-1" role="presentation"></a>ECMAScript modules</h2>

<p><a class="p_ident" id="p_ZB3AF/XP4y" href="#p_ZB3AF/XP4y" tabindex="-1" role="presentation"></a>CommonJS modules work quite well and, in combination with NPM, have allowed the JavaScript community to start sharing code on a large scale.</p>

<p><a class="p_ident" id="p_yy6++k1U8b" href="#p_yy6++k1U8b" tabindex="-1" role="presentation"></a>But they remain a bit of a duct-tape hack. The notation is slightly awkward—the things you add to <code>exports</code> are not available in the local scope, for example. And because <code>require</code> is a normal function call taking any kind of argument, not just a string literal, it can be hard to determine the dependencies of a module without running its code.</p>

<p id="es"><a class="p_ident" id="p_fGE1JkAJHH" href="#p_fGE1JkAJHH" tabindex="-1" role="presentation"></a>This is why the JavaScript standard from 2015 introduces its own, different module system. It is usually called <em>ES modules</em>, where <em>ES</em> stands for ECMAScript. The main concepts of dependencies and interfaces remain the same, but the details differ. For one thing, the notation is now integrated into the language. Instead of calling a function to access a dependency, you use a special <code>import</code> keyword.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EpiH8qOAcJ" href="#c_EpiH8qOAcJ" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> <span class="cm-def">ordinal</span> <span class="cm-keyword">from</span> <span class="cm-string">&quot;ordinal&quot;</span>;
<span class="cm-keyword">import</span> {<span class="cm-def">days</span>, <span class="cm-def">months</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;date-names&quot;</span>;

<span class="cm-keyword">export</span> <span class="cm-keyword">function</span> <span class="cm-def">formatDate</span>(<span class="cm-def">date</span>, <span class="cm-def">format</span>) { <span class="cm-comment">/* ... */</span> }</pre>

<p><a class="p_ident" id="p_Md0hUIO/t1" href="#p_Md0hUIO/t1" tabindex="-1" role="presentation"></a>Similarly, the <code>export</code> keyword is used to export things. It may appear in front of a function, class, or binding definition (<code>let</code>, <code>const</code>, or <code>var</code>).</p>

<p><a class="p_ident" id="p_2XcNI5i8RP" href="#p_2XcNI5i8RP" tabindex="-1" role="presentation"></a>An ES module’s interface is not a single value but a set of named bindings. The preceding module binds <code>formatDate</code> to a function. When you import from another module, you import the <em>binding</em>, not the value, which means an exporting module may change the value of the binding at any time, and the modules that import it will see its new value.</p>

<p><a class="p_ident" id="p_H96aQvDt7C" href="#p_H96aQvDt7C" tabindex="-1" role="presentation"></a>When there is a binding named <code>default</code>, it is treated as the module’s main exported value. If you import a module like <code>ordinal</code> in the example, without braces around the binding name, you get its <code>default</code> binding. Such modules can still export other bindings under different names alongside their <code>default</code> export.</p>

<p><a class="p_ident" id="p_C4XHB0ByrT" href="#p_C4XHB0ByrT" tabindex="-1" role="presentation"></a>To create a default export, you write <code>export default</code> before an expression, a function declaration, or a class declaration.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Y6Wnu9X+/W" href="#c_Y6Wnu9X+/W" tabindex="-1" role="presentation"></a><span class="cm-keyword">export</span> <span class="cm-keyword">default</span> [<span class="cm-string">&quot;Winter&quot;</span>, <span class="cm-string">&quot;Spring&quot;</span>, <span class="cm-string">&quot;Summer&quot;</span>, <span class="cm-string">&quot;Autumn&quot;</span>];</pre>

<p><a class="p_ident" id="p_XbHIrV+nuJ" href="#p_XbHIrV+nuJ" tabindex="-1" role="presentation"></a>It is possible to rename imported bindings using the word <code>as</code>.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_I7jPaQvsXj" href="#c_I7jPaQvsXj" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">days</span> <span class="cm-keyword">as</span> <span class="cm-def">dayNames</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;date-names&quot;</span>;

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayNames</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 7</span></pre>

<p><a class="p_ident" id="p_oqym70c7ZR" href="#p_oqym70c7ZR" tabindex="-1" role="presentation"></a>Another important difference is that ES module imports happen before a module’s script starts running. That means <code>import</code> declarations may not appear inside functions or blocks, and the names of dependencies must be quoted strings, not arbitrary expressions.</p>

<p><a class="p_ident" id="p_+UaRV7zy4m" href="#p_+UaRV7zy4m" tabindex="-1" role="presentation"></a>At the time of writing, the JavaScript community is in the process of adopting this module style. But it has been a slow process. It took a few years, after the format was specified, for browsers and Node.js to start supporting it. And though they mostly support it now, this support still has issues, and the discussion on how such modules should be distributed through NPM is still ongoing.</p>

<p><a class="p_ident" id="p_UEipP/dEjR" href="#p_UEipP/dEjR" tabindex="-1" role="presentation"></a>Many projects are written using ES modules and then automatically converted to some other format when published. We are in a transitional period in which two different module systems are used side by side, and it is useful to be able to read and write code in either of them.</p>

<h2><a class="h_ident" id="h_zWTXAU93DC" href="#h_zWTXAU93DC" tabindex="-1" role="presentation"></a>Building and bundling</h2>

<p><a class="p_ident" id="p_Si0Uy8W7Rk" href="#p_Si0Uy8W7Rk" tabindex="-1" role="presentation"></a>In fact, many JavaScript projects aren’t even, technically, written in JavaScript. There are extensions, such as the type checking dialect mentioned in <a href="08_error.html#typing">Chapter 8</a>, that are widely used. People also often start using planned extensions to the language long before they have been added to the platforms that actually run JavaScript.</p>

<p><a class="p_ident" id="p_8YI40LC/+x" href="#p_8YI40LC/+x" tabindex="-1" role="presentation"></a>To make this possible, they <em>compile</em> their code, translating it from their chosen JavaScript dialect to plain old JavaScript—or even to a past version of JavaScript—so that old browsers can run it.</p>

<p><a class="p_ident" id="p_xCwSgQaAdq" href="#p_xCwSgQaAdq" tabindex="-1" role="presentation"></a>Including a modular program that consists of 200 different files in a web page produces its own problems. If fetching a single file over the network takes 50 milliseconds, loading the whole program takes 10 seconds, or maybe half that if you can load several files simultaneously. That’s a lot of wasted time. Because fetching a single big file tends to be faster than fetching a lot of tiny ones, web programmers have started using tools that roll their programs (which they painstakingly split into modules) back into a single big file before they publish it to the Web. Such tools are called <em>bundlers</em>.</p>

<p><a class="p_ident" id="p_F5bhvXPahh" href="#p_F5bhvXPahh" tabindex="-1" role="presentation"></a>And we can go further. Apart from the number of files, the <em>size</em> of the files also determines how fast they can be transferred over the network. Thus, the JavaScript community has invented <em>minifiers</em>. These are tools that take a JavaScript program and make it smaller by automatically removing comments and whitespace, renaming bindings, and replacing pieces of code with equivalent code that take up less space.</p>

<p><a class="p_ident" id="p_0kzBnsBjVM" href="#p_0kzBnsBjVM" tabindex="-1" role="presentation"></a>So it is not uncommon for the code that you find in an NPM package or that runs on a web page to have gone through <em>multiple</em> stages of transformation—converted from modern JavaScript to historic JavaScript, from ES module format to CommonJS, bundled, and minified. We won’t go into the details of these tools in this book since they tend to be boring and change rapidly. Just be aware that the JavaScript code you run is often not the code as it was written.</p>

<h2><a class="h_ident" id="h_P8pyzbI9vO" href="#h_P8pyzbI9vO" tabindex="-1" role="presentation"></a>Module design</h2>

<p><a class="p_ident" id="p_8K2T8s7itK" href="#p_8K2T8s7itK" tabindex="-1" role="presentation"></a>Structuring programs is one of the subtler aspects of programming. Any nontrivial piece of functionality can be modeled in various ways.</p>

<p><a class="p_ident" id="p_98c2qP5s8p" href="#p_98c2qP5s8p" tabindex="-1" role="presentation"></a>Good program design is subjective—there are trade-offs involved and matters of taste. The best way to learn the value of well-structured design is to read or work on a lot of programs and notice what works and what doesn’t. Don’t assume that a painful mess is “just the way it is”. You can improve the structure of almost everything by putting more thought into it.</p>

<p><a class="p_ident" id="p_AF7qUrMoR4" href="#p_AF7qUrMoR4" tabindex="-1" role="presentation"></a>One aspect of module design is ease of use. If you are designing something that is intended to be used by multiple people—or even by yourself, in three months when you no longer remember the specifics of what you did—it is helpful if your interface is simple and predictable.</p>

<p><a class="p_ident" id="p_hHDSnM2Orb" href="#p_hHDSnM2Orb" tabindex="-1" role="presentation"></a>That may mean following existing conventions. A good example is the <code>ini</code> package. This module imitates the standard <code>JSON</code> object by providing <code>parse</code> and <code>stringify</code> (to write an INI file) functions, and, like <code>JSON</code>, converts between strings and plain objects. So the interface is small and familiar, and after you’ve worked with it once, you’re likely to remember how to use it.</p>

<p><a class="p_ident" id="p_uS+as91Giv" href="#p_uS+as91Giv" tabindex="-1" role="presentation"></a>Even if there’s no standard function or widely used package to imitate, you can keep your modules predictable by using simple data
structures and doing a single, focused thing. Many of the INI-file parsing modules on NPM provide a function that directly reads such a file from the hard disk and parses it, for example. This makes it impossible to use such modules in the browser, where we don’t have direct file system access, and adds complexity that would have been better addressed by <em>composing</em> the module with some file-reading function.</p>

<p><a class="p_ident" id="p_JYcq/PgjlO" href="#p_JYcq/PgjlO" tabindex="-1" role="presentation"></a>This points to another helpful aspect of module design—the ease with which something can be composed with other code. Focused modules that compute values are applicable in a wider range of programs than bigger modules that perform complicated actions with side effects. An INI file reader that insists on reading the file from disk is useless in a scenario where the file’s content comes from some other source.</p>

<p><a class="p_ident" id="p_6cqySeVoki" href="#p_6cqySeVoki" tabindex="-1" role="presentation"></a>Relatedly, stateful objects are sometimes useful or even necessary, but if something can be done with a function, use a function. Several of the INI file readers on NPM provide an interface style that requires you to first create an object, then load the file into your object, and finally use specialized methods to get at the results. This type of thing is common in the object-oriented tradition, and it’s terrible. Instead of making a single function call and moving on, you have to perform the ritual of moving your object through various states. And because the data is now wrapped in a specialized object type, all code that interacts with it has to know about that type, creating unnecessary interdependencies.</p>

<p><a class="p_ident" id="p_uR7iWbgBIy" href="#p_uR7iWbgBIy" tabindex="-1" role="presentation"></a>Often defining new data structures can’t be avoided—only a few basic ones are provided by the language standard, and many types of data have to be more complex than an array or a map. But when an array suffices, use an array.</p>

<p><a class="p_ident" id="p_gE7WoNX7+Z" href="#p_gE7WoNX7+Z" tabindex="-1" role="presentation"></a>An example of a slightly more complex data structure is the graph from <a href="07_robot.html">Chapter 7</a>. There is no single obvious way to represent a graph in JavaScript. In that chapter, we used an object whose properties hold arrays of strings—the other nodes reachable from that node.</p>

<p><a class="p_ident" id="p_17Fkotj+nV" href="#p_17Fkotj+nV" tabindex="-1" role="presentation"></a>There are several different pathfinding packages on NPM, but none of them uses this graph format. They usually allow the graph’s edges to have a weight, which is the cost or distance associated with it. That isn’t possible in our representation.</p>

<p><a class="p_ident" id="p_d3wpFXYEjN" href="#p_d3wpFXYEjN" tabindex="-1" role="presentation"></a>For example, there’s the <code>dijkstrajs</code> package. A well-known approach to pathfinding, quite similar to our <code>findRoute</code> function, is called <em>Dijkstra’s algorithm</em>, after Edsger Dijkstra, who first wrote it down. The <code>js</code> suffix is often added to package names to indicate the fact that they are written in JavaScript. This <code>dijkstrajs</code> package uses a graph format similar to ours, but instead of arrays, it uses objects whose property values are numbers—the weights of the edges.</p>

<p><a class="p_ident" id="p_3iug1e4kQG" href="#p_3iug1e4kQG" tabindex="-1" role="presentation"></a>So if we wanted to use that package, we’d have to make sure that our graph was stored in the format it expects. All edges get the same weight since our simplified model treats each road as having the same cost (one turn).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_NyRXVpwPYN" href="#c_NyRXVpwPYN" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">find_path</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;dijkstrajs&quot;</span>);

<span class="cm-keyword">let</span> <span class="cm-def">graph</span> <span class="cm-operator">=</span> {};
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">node</span> <span class="cm-keyword">of</span> <span class="cm-variable">Object</span>.<span class="cm-property">keys</span>(<span class="cm-variable">roadGraph</span>)) {
  <span class="cm-keyword">let</span> <span class="cm-def">edges</span> <span class="cm-operator">=</span> <span class="cm-variable">graph</span>[<span class="cm-variable">node</span>] <span class="cm-operator">=</span> {};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">dest</span> <span class="cm-keyword">of</span> <span class="cm-variable">roadGraph</span>[<span class="cm-variable">node</span>]) {
    <span class="cm-variable-2">edges</span>[<span class="cm-variable-2">dest</span>] <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">find_path</span>(<span class="cm-variable">graph</span>, <span class="cm-string">&quot;Post Office&quot;</span>, <span class="cm-string">&quot;Cabin&quot;</span>));
<span class="cm-comment">// → [&quot;Post Office&quot;, &quot;Alice's House&quot;, &quot;Cabin&quot;]</span></pre>

<p><a class="p_ident" id="p_X8Ulb726ZC" href="#p_X8Ulb726ZC" tabindex="-1" role="presentation"></a>This can be a barrier to composition—when various packages are using different data structures to describe similar things, combining them is difficult. Therefore, if you want to design for composability, find out what data structures other people are using and, when possible, follow their example.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>Summary</h2>

<p><a class="p_ident" id="p_OX2jY0nGFw" href="#p_OX2jY0nGFw" tabindex="-1" role="presentation"></a>Modules provide structure to bigger programs by separating the code into pieces with clear interfaces and dependencies. The interface is the part of the module that’s visible from other modules, and the dependencies are the other modules that it makes use of.</p>

<p><a class="p_ident" id="p_sYCJxIhCEI" href="#p_sYCJxIhCEI" tabindex="-1" role="presentation"></a>Because JavaScript historically did not provide a module system, the CommonJS system was built on top of it. Then at some point it <em>did</em> get a built-in system, which now coexists uneasily with the CommonJS system.</p>

<p><a class="p_ident" id="p_wDM2Q8HBcB" href="#p_wDM2Q8HBcB" tabindex="-1" role="presentation"></a>A package is a chunk of code that can be distributed on its own. NPM is a repository of JavaScript packages. You can download all kinds of useful (and useless) packages from it.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>Exercises</h2>

<h3><a class="i_ident" id="i_CJKk6NIC0T" href="#i_CJKk6NIC0T" tabindex="-1" role="presentation"></a>A modular robot</h3>

<p id="modular_robot"><a class="p_ident" id="p_nPAEnO4pep" href="#p_nPAEnO4pep" tabindex="-1" role="presentation"></a>These are the bindings that the project from <a href="07_robot.html">Chapter 7</a> creates:</p>

<pre class="snippet cm-s-default" data-language="text/plain" ><a class="c_ident" id="c_/nxTd1W0Sy" href="#c_/nxTd1W0Sy" tabindex="-1" role="presentation"></a>roads
buildGraph
roadGraph
VillageState
runRobot
randomPick
randomRobot
mailRoute
routeRobot
findRoute
goalOrientedRobot</pre>

<p><a class="p_ident" id="p_0LdymcLoV8" href="#p_0LdymcLoV8" tabindex="-1" role="presentation"></a>If you were to write that project as a modular program, what modules would you create? Which module would depend on which other module, and what would their interfaces look like?</p>

<p><a class="p_ident" id="p_hU/u/IPER+" href="#p_hU/u/IPER+" tabindex="-1" role="presentation"></a>Which pieces are likely to be available prewritten on NPM? Would you prefer to use an NPM package or write them yourself?</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_o3MT4wM7DB" href="#p_o3MT4wM7DB" tabindex="-1" role="presentation"></a>Here’s what I would have done (but again, there is no single <em>right</em> way to design a given module):</p>

<p><a class="p_ident" id="p_56/CQgKTat" href="#p_56/CQgKTat" tabindex="-1" role="presentation"></a>The code used to build the road graph lives in the <code>graph</code> module. Because I’d rather use <code>dijkstrajs</code> from NPM than our own pathfinding code, we’ll make this build the kind of graph data that <code>dijkstajs</code> expects. This module exports a single function, <code>buildGraph</code>. I’d have <code>buildGraph</code> accept an array of two-element arrays, rather than strings containing hyphens, to make the module less dependent on the input format.</p>

<p><a class="p_ident" id="p_B6Z6VXRXv9" href="#p_B6Z6VXRXv9" tabindex="-1" role="presentation"></a>The <code>roads</code> module contains the raw road data (the <code>roads</code> array) and the <code>roadGraph</code> binding. This module depends on <code>./graph</code> and exports the road graph.</p>

<p><a class="p_ident" id="p_JLwefzFde0" href="#p_JLwefzFde0" tabindex="-1" role="presentation"></a>The <code>VillageState</code> class lives in the <code>state</code> module. It depends on the <code>./roads</code> module because it needs to be able to verify that a given road exists. It also needs <code>randomPick</code>. Since that is a three-line function, we could just put it into the <code>state</code> module as an internal helper function. But <code>randomRobot</code> needs it too. So we’d have to either duplicate it or put it into its own module. Since this function happens to exist on NPM in the <code>random-item</code> package, a good solution is to just make both modules depend on that. We can add the <code>runRobot</code> function to this module as well, since it’s small and closely related to state management. The module exports both the <code>VillageState</code> class and the <code>runRobot</code> function.</p>

<p><a class="p_ident" id="p_wJDmndPhIc" href="#p_wJDmndPhIc" tabindex="-1" role="presentation"></a>Finally, the robots, along with the values they depend on such as <code>mailRoute</code>, could go into an <code>example-robots</code> module, which depends on <code>./roads</code> and exports the robot functions. To make it possible for <code>goalOrientedRobot</code> to do route-finding, this module also depends on <code>dijkstrajs</code>.</p>

<p><a class="p_ident" id="p_jU189+mtkS" href="#p_jU189+mtkS" tabindex="-1" role="presentation"></a>By offloading some work to NPM modules, the code became a little smaller. Each individual module does something rather simple and can be read on its own. Dividing code into modules also often suggests further improvements to the program’s design. In this case, it seems a little odd that the <code>VillageState</code> and the robots depend on a specific road graph. It might be a better idea to make the graph an argument to the state’s constructor and make the robots read it from the state object—this reduces dependencies (which is always good) and makes it possible to run simulations on different maps (which is even better).</p>

<p><a class="p_ident" id="p_rfGj5/gdUx" href="#p_rfGj5/gdUx" tabindex="-1" role="presentation"></a>Is it a good idea to use NPM modules for things that we could have written ourselves? In principle, yes—for nontrivial things like the pathfinding function you are likely to make mistakes and waste time writing them yourself. For tiny functions like <code>random-item</code>, writing them yourself is easy enough. But adding them wherever you need them does tend to clutter your modules.</p>

<p><a class="p_ident" id="p_shhnxYPdPj" href="#p_shhnxYPdPj" tabindex="-1" role="presentation"></a>However, you should also not underestimate the work involved in <em>finding</em> an appropriate NPM package. And even if you find one, it might not work well or may be missing some feature you need. On top of that, depending on NPM packages means you have to make sure they are installed, you have to distribute them with your program, and you might have to periodically upgrade them.</p>

<p><a class="p_ident" id="p_UgTNT3/2gd" href="#p_UgTNT3/2gd" tabindex="-1" role="presentation"></a>So again, this is a trade-off, and you can decide either way depending on how much the packages help you.</p>

</div></div>

<h3><a class="i_ident" id="i_+pU//gQmZ8" href="#i_+pU//gQmZ8" tabindex="-1" role="presentation"></a>Roads module</h3>

<p><a class="p_ident" id="p_U88wPDSl2i" href="#p_U88wPDSl2i" tabindex="-1" role="presentation"></a>Write a CommonJS module, based on the example from <a href="07_robot.html">Chapter 7</a>, that contains the array of roads and exports the graph data structure representing them as <code>roadGraph</code>. It should depend on a module <code>./graph</code>, which exports a function <code>buildGraph</code> that is used to build the graph. This function expects an array of two-element arrays (the start and end points of the roads).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FPEwj7xDOs" href="#c_FPEwj7xDOs" tabindex="-1" role="presentation"></a><span class="cm-comment">// Add dependencies and exports</span>

<span class="cm-keyword">const</span> <span class="cm-def">roads</span> <span class="cm-operator">=</span> [
  <span class="cm-string">&quot;Alice's House-Bob's House&quot;</span>,   <span class="cm-string">&quot;Alice's House-Cabin&quot;</span>,
  <span class="cm-string">&quot;Alice's House-Post Office&quot;</span>,   <span class="cm-string">&quot;Bob's House-Town Hall&quot;</span>,
  <span class="cm-string">&quot;Daria's House-Ernie's House&quot;</span>, <span class="cm-string">&quot;Daria's House-Town Hall&quot;</span>,
  <span class="cm-string">&quot;Ernie's House-Grete's House&quot;</span>, <span class="cm-string">&quot;Grete's House-Farm&quot;</span>,
  <span class="cm-string">&quot;Grete's House-Shop&quot;</span>,          <span class="cm-string">&quot;Marketplace-Farm&quot;</span>,
  <span class="cm-string">&quot;Marketplace-Post Office&quot;</span>,     <span class="cm-string">&quot;Marketplace-Shop&quot;</span>,
  <span class="cm-string">&quot;Marketplace-Town Hall&quot;</span>,       <span class="cm-string">&quot;Shop-Town Hall&quot;</span>
];</pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_KWk09Gyhem" href="#p_KWk09Gyhem" tabindex="-1" role="presentation"></a>Since this is a CommonJS module, you have to use <code>require</code> to import the graph module. That was described as exporting a <code>buildGraph</code> function, which you can pick out of its interface object with a destructuring <code>const</code> declaration.</p>

<p><a class="p_ident" id="p_zdT6jLwIjp" href="#p_zdT6jLwIjp" tabindex="-1" role="presentation"></a>To export <code>roadGraph</code>, you add a property to the <code>exports</code> object. Because <code>buildGraph</code> takes a data structure that doesn’t precisely match <code>roads</code>, the splitting of the road strings must happen in your module.</p>

</div></div>

<h3><a class="i_ident" id="i_E/zWqBFdy8" href="#i_E/zWqBFdy8" tabindex="-1" role="presentation"></a>Circular dependencies</h3>

<p><a class="p_ident" id="p_fl2MZMonQV" href="#p_fl2MZMonQV" tabindex="-1" role="presentation"></a>A circular dependency is a situation where module A depends on B, and B also, directly or indirectly, depends on A. Many module systems simply forbid this because whichever order you choose for loading such modules, you cannot make sure that each module’s dependencies have been loaded before it runs.</p>

<p><a class="p_ident" id="p_b5sTJIUt38" href="#p_b5sTJIUt38" tabindex="-1" role="presentation"></a>CommonJS modules allow a limited form of cyclic dependencies. As long as the modules do not replace their default <code>exports</code> object and don’t access each other’s interface until after they finish loading, cyclic dependencies are okay.</p>

<p><a class="p_ident" id="p_s/oDnu78Ko" href="#p_s/oDnu78Ko" tabindex="-1" role="presentation"></a>The <code>require</code> function given <a href="10_modules.html#require">earlier in this chapter</a> supports this type of dependency cycle. Can you see how it handles cycles? What would go wrong when a module in a cycle <em>does</em> replace its default <code>exports</code> object?</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_nf2U1lY9dq" href="#p_nf2U1lY9dq" tabindex="-1" role="presentation"></a>The trick is that <code>require</code> adds modules to its cache <em>before</em> it starts loading the module. That way, if any <code>require</code> call made while it is running tries to load it, it is already known, and the current interface will be returned, rather than starting to load the module once more (which would eventually overflow the stack).</p>

<p><a class="p_ident" id="p_QAZLbqVKnV" href="#p_QAZLbqVKnV" tabindex="-1" role="presentation"></a>If a module overwrites its <code>module.exports</code> value, any other module that has received its interface value before it finished loading will have gotten hold of the default interface object (which is likely empty), rather than the intended interface value.</p>

</div></div>

<nav><a href="09_regexp.html" title="previous chapter">◀</a> 
  <a href="index.html" title="cover">◆</a> <a href="11_async.html" title="next chapter">▶</a>
</nav>
</article>
